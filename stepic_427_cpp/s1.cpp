/*
Струтура данных стек позволяет хранить элементы в порядке, обратном порядку их добавления (т.е. 
последний добавленный элемент будет вытащен из стека раньше всех). Обычно для стека выделяют две 
главные операции: push и pop. Операция push добавляет элемент в стек, а pop — удаляет из стека 
последний добавленный элемент.

В данном задании вам предлагается реализовать структуру данных стек для хранения целых чисел, 
назовём эту структуру IntStack. Следующий код показывает пример работы с этой структурой.

	IntStack s;
	for (int i = 1; i != 10; ++i)
    	s.push(i); // добавляем числа от одного до 10

	while (s.size() > 0) {
	    std::cout << s.top() << ' '; // печатаем верхних элемент стека
		s.pop(); // удаляем верхний элемент стека
	}
	// на cout будет выведено "9 8 7 6 5 4 3 2 1 "

Можно реализовывать стек разными способами. В данном задании вам нужно реализовать стек на массиве: 
элеметы стека хранятся в динамическом массиве, если массива недостаточно, то выделяется новый массив 
в два раза большего размера.
Структура стека и его методы уже описаны в шаблоне, вам нужно только правильно реализовать их.

Требования к реализации: в данном задании запрещено использовать строки или контейнеры STL (даже, 
если вы с ними уже знакомы). Вам разрешено заводить вспомогательные методы, если они вам нужны, 
но запрещего добавлять поля.  При реализации не нужно вводить или выводить что-либо. Реализовывать 
main не нужно. Не используйте функции из cstdlib (malloc, calloc, realloc и free).
*/

using namespace std;

// стека для целых чисел
struct IntStack {
	// конструкторы
	IntStack() : data_(NULL), size_(0), capacity_(2) {
		data_ = new int[capacity_];
	}
	IntStack(IntStack const& s) {
		size_ = s.size_;
		capacity_ = s.capacity_;
		//delete[] data_;
		data_ = new int[capacity_];
		for (size_t i = 0; i <= size_; ++i) data_[i] = s.data_[i];
	}

	// деструктор
	~IntStack() {
		delete[] data_;
	}

	// оператор присваивания
	IntStack & operator=(IntStack const &s) {
		if (this == &s) return *this;
		size_ = s.size_;
		capacity_ = s.capacity_;
		delete[] data_;
		data_ = new int[capacity_];
		for (size_t i = 0; i <= size_; ++i) data_[i] = s.data_[i];
		return *this;
	}

	// размер стека
	size_t size() const { return size_; }

	// операции

	// добавить элемент
	void push(int i) {
		if (size_ + 1 < capacity_) {
			++size_;
			data_[size_] = i;
		}
		else {
			capacity_ *= 2;
			int *temp = new int[capacity_];
			for (int i = 0; i <= size_; ++i) temp[i] = data_[i];
			delete[] data_;
			data_ = temp;
			++size_;
			data_[size_] = i;
		}
	}

	// удалить элемент
	void pop() {
		if (size_ != 0) --size_;
	}

	// получить элемент на вершине стека
	int top() const {
		if (size_ != 0) return data_[size_];
		// не понятно из условия задачи что делать если стек пустой
		else return 0;
	}

	// поля данных
	// не менять!
private:
	int * data_;      // массив
	size_t size_;     // количество элементов в массиве
	size_t capacity_; // размер массива
};